{$DEFINE SRL_INTERFACE_INCLUDED}
{$IFNDEF SRL_OSR}
  {$I SRL/osr.simba}
{$ENDIF}

{$i interface_boundsfinder.simba}
{$i interface_itemfinder.simba}

type
  ERSInterfaceElementAnchor = (TOP, BOTTOM);

  TRSInterfaceElement = record
    Name: String;
    Anchor: ERSInterfaceElementAnchor;
    Offset: TPoint;
    Width, Height: Int32;
  end;
  TRSInterfaceElementArray = array of TRSInterfaceElement;
  
  TRSInterface = record(TSRLBaseRecord)
    Elements: TRSInterfaceElementArray;

    BoundsFinder: TRSInterfaceBoundsFinder;
    ItemFinder: TRSInterfaceItemFinder;
  end;

{%codetools off}
// todo: macro?

function TRSInterface._ElementBounds(constref Element: TRSInterfaceElement): TBox;
var
  B: TBox;
begin
  B := Self.Bounds();

  case Element.Anchor of
    ERSInterfaceElementAnchor.TOP:
      begin
        Result.X1 := B.X1 + Element.Offset.X;
        Result.Y1 := B.Y1 + Element.Offset.Y;

        Result.X2 := Result.X1 + Element.Width-1; // fixme
        Result.Y2 := Result.Y1 + Element.Height-1;
      end;

    ERSInterfaceElementAnchor.BOTTOM:
      begin
        Result.X1 := B.X1 + Element.Offset.X;
        Result.Y2 := B.Y1 + Element.Offset.Y + B.Height;

        Result.X2 := Result.X1 + Element.Width-1;
        Result.Y1 := Result.Y2 - Element.Height-1;
      end;
  end;
end;

procedure TRSInterface._ElementClick(constref Element: TRSInterfaceElement; Button: Integer = MOUSE_LEFT); overload;
begin
  Mouse.Click(Self._ElementBounds(Element), Button);
end;

function TRSInterface._ElementClick(constref Element: TRSInterfaceElement; Option: String): Boolean; overload;
begin
  Mouse.Move(Self._ElementBounds(Element));

  Result := ChooseOption.Select(Option);
end;

function TRSInterface._ElementCountColor(constref Element: TRSInterfaceElement; Color, Tolerance: Integer): Integer;
begin
  Result := CountColorTolerance(Color, Self._ElementBounds(Element), Tolerance);
end;

function TRSInterface._ElementFindText(constref Element: TRSInterfaceElement; constref Colors: TIntegerArray; constref Text: String; constref Font: TFontSet): Boolean;
var
  B: TBox;
begin
  Result := OCR.LocateText(Self._ElementBounds(Element), Text, Font, TOCRColorFilter.Create(Colors), B) = 1;
end;

function TRSInterface._ElementToggle(constref Element: TRSInterfaceElement; Color, Tolerance: Integer; MinColorCount: Integer): Boolean;
begin
  if Self._ElementCountColor(Element, Color, Tolerance) > MinColorCount then
    Exit(True);

  Self._ElementClick(Element);

  Result := WaitUntil(Self._ElementCountColor(Element, Color, Tolerance) > MinColorCount, 50, SRL.TruncatedGauss(1000, 1500));
end;

function TRSInterface._ElementRecognizeNumber(constref Element: TRSInterfaceElement; constref Colors: TIntegerArray; constref Font: TFontSet): Int64;
begin
  Result := OCR.RecognizeNumber(Self._ElementBounds(Element), TOCRColorFilter.Create(Colors), Font);
end;

function TRSInterface._ElementRecognizeText(constref Element: TRSInterfaceElement; constref Colors: TIntegerArray; constref Font: TFontSet): String;
begin
  Result := OCR.Recognize(Self._ElementBounds(Element), TOCRColorFilter.Create(Colors), Font);
end;
{%codetools on}

procedure TRSInterface.Setup(Name: String);
begin
  Self.Name := Name;
end;

function TRSInterface.Bounds: TBox;
begin
  Result := Self.BoundsFinder.Find(RSClient.ClientMode);
end;

function TRSInterface.X1: Int32;
begin
  Result := Bounds.X1;
end;

function TRSInterface.X2: Int32;
begin
  Result := Bounds.X2;
end;

function TRSInterface.Y1: Int32;
begin
  Result := Bounds.Y1;
end;

function TRSInterface.Y2: Int32;
begin
  Result := Bounds.Y2;
end;

function TRSInterface.Width: Int32; 
begin
  Result := Bounds.Width;
end;

function TRSInterface.Height: Int32; 
begin
  Result := Bounds.Height;
end;

function TRSInterface.Center: TPoint; 
begin
  Result := Self.Bounds().Middle;
end;

type
  TRSScrollBar = record
    SliderRegion: TBox;
    Slider: TBox;
    Position: Int32;
  end;
  
procedure TRSScrollBar.Draw(Bitmap: TMufasaBitmap); constref;
begin
  Bitmap.DrawBox(Self.SliderRegion, $00FFFF);
  Bitmap.DrawBox(Self.Slider, $00FFFF);
  Bitmap.SetFontAntialiasing(False);
  Bitmap.SetFontSize(20);
  with Bitmap.TextSize(ToString(Self.Position)) do
    Bitmap.DrawText(ToString(Self.Position), [Self.SliderRegion.Middle.X - (X div 2), Self.Slider.Middle.Y - (Y div 3)], $00FF00);
end;

function TRSScrollBar.IsVisible: Boolean;
begin
  Result := Self <> [];
end;

function TRSInterface.GetScrollBar: TRSScrollBar;
const
  COLOR_ARROW := CTS2(5206147, 15, 0.03, 0.28);
  COLOR_BORDER := 65536;
var
  TPA: TPointArray;
  Arrows: TBoxArray;
  Area, B: TBox;
begin
  Area := Self.Bounds();
  
  if SRL.FindColors(TPA, COLOR_ARROW, Area) > 0 then
  begin
    for B in TPA.Cluster(1).Bounds() do
      if (B.Width = 14) and (B.Height = 14) and (SRL.CountColor(COLOR_BORDER, B.Expand(1, Area)) = 62) then
        Arrows += B;
        
    Arrows.SortByX(False);   
    
    if (Length(Arrows) >= 2) and (Arrows[0].X1 = Arrows[1].X1) and (Arrows[1].X2 = Arrows[1].X2) then
    begin
      if (Arrows[0].Y1 > Arrows[1].Y1) then
        Swap(Arrows[0], Arrows[1]);
        
      B.X1 := Arrows[0].X1;
      B.Y1 := Arrows[0].Y2 + 2;
      B.X2 := Arrows[1].X2;
      B.Y2 := Arrows[1].Y1 - 2;
  
      if SRL.FindColors(TPA, COLOR_BORDER, B) > 0 then 
      begin
        Result.SliderRegion := B;
        Result.Slider := TPA.Bounds;
        Result.Position := Round((Result.Slider.Y1 - Result.SliderRegion.Y1) * 100 / (Result.SliderRegion.Height - Result.Slider.Height));
      end;
    end; 
  end;
end;

function TRSInterface.CanScroll: Boolean;
var
  ScrollBar: TRSScrollBar := Self.GetScrollBar();
begin
  Result := Scrollbar.IsVisible() and (ScrollBar.Slider <> ScrollBar.SliderRegion);
end;

function TRSInterface.GetScrollPosition: Int32;
var
  ScrollBar: TRSScrollBar;
begin
  Result := -1;
  
  ScrollBar := Self.GetScrollBar();
  if ScrollBar.IsVisible() then
    Result := ScrollBar.Position;
end;

procedure TRSInterface.SetScrollPosition(Value: Int32);
var
  ScrollBar: TRSScrollBar;
begin
  if (Value < 0) then
    Value := 0;
  if (Value > 100) then
    Value := 100;

  ScrollBar := Self.GetScrollBar();
  
  if ScrollBar.IsVisible() then
  begin
    if (ScrollBar.Position < Value) then 
    begin 
      while ScrollBar.IsVisible() and (ScrollBar.Position < Value) do
      begin
        Mouse.Scroll(ScrollBar.SliderRegion, Random(1, 3), True);
        
        ScrollBar := Self.GetScrollBar();
      end;
    end else
    if (ScrollBar.Position > Value) then 
    begin
      while ScrollBar.IsVisible() and (ScrollBar.Position > Value) do
      begin
        Mouse.Scroll(ScrollBar.SliderRegion, Random(1, 3), False);
        
        ScrollBar := Self.GetScrollBar();
      end;
    end;
  end;
end;

procedure TRSInterface.Draw(Bitmap: TMufasaBitmap);
var
  ScrollBar: TRSScrollBar;
  I: Integer;
begin
  Bitmap.DrawBox(Self.Bounds(), $00FFFF);

  for I:=0 to High(Self.Elements) do
    Bitmap.DrawBox(Self._ElementBounds(Self.Elements[I]), $00FF00);

  ScrollBar := Self.GetScrollBar();
  if ScrollBar.IsVisible() then
    ScrollBar.Draw(Bitmap); 
end;

{
function TRSInterface.IsOpen: Boolean; overload;
begin
  //if (not Assigned(@Self.InternalMethods.IsOpen)) then
  //  raise 'no is open';

  if @Self.Methods.IsOpen <> nil then
    Result := Self.Methods.IsOpen()
  else
    Result := True;
end;

function TRSInterface.IsOpen(WaitTime: Int32; Interval: Int32 = -1): Boolean; overload;
begin
  if (Interval = -1) then
    Interval := SRL.TruncatedGauss(50, 1500);

  Result := WaitUntil(Self.IsOpen(), Interval, WaitTime);
end;

function TRSInterface.Close(PressEscape: Boolean = False): Boolean;
const
  bmp := BitmapFromString(21, 21, 'meJxjZGBgpAyRDaio3dwzmHhEI+0QEUz1aOL4taOZgCmIqd3SNxKC4IqxciEIj3ZkLVj1YtVuExSPjJD1okkBEUHtcBMwxYnRTqrtDuEpcITpd2RZIMKjHU0LVhMwtTvH5gARXDGEi0sQv3ZkvVjFcWknElFdOxmAKtopQQAaR5/Q');
var
  X, Y, W, H: Integer;
begin
  if PressEscape then
    Keyboard.PressKey(VK_ESCAPE)
  else
  begin
    if not FindBitmapToleranceIn(bmp, X, Y, Box(Bounds.X2 - 50, Bounds.Y1, Bounds.X2, Bounds.Y1 + 50), 45) then
      Exit;

    GetBitmapSize(bmp, W, H);
    Mouse.Click([X,Y,X+W-1,Y+H-1], MOUSE_LEFT);
  end;

  Result := WaitUntil(not Self.IsOpen(), 100, 2000);
end;
}

function TRSInterface.IsTitle(Text: String; MinMatch: Single = 0.80): Boolean;
var
  B: TBox;
begin
  B := Self.Bounds();
  B.X1 += 70;
  B.Y1 += 10;
  B.X2 -= 70;
  B.Y2 := B.Y1 + 15;
  B.Clip(Self.Bounds);

  Result := OCR.LocateText(B, Text, RS_FONT_BOLD_12, TOCRInvertColorFilter.Create([3358536, 0], [5, 0]), B) > MinMatch;
end;

type
  TRSRootInterface = type TRSInterface;

function TRSRootInterface.CustomBoundsFinder(ClientMode: ERSClientMode): TBox;
var
  W, H: Integer;
begin
  GetClientDimensions(W, H);

  Result.X1 := 0;
  Result.Y1 := 0;
  Result.X2 := W-1;
  Result.Y2 := H-1;
end;

procedure TRSRootInterface.Setup(Name: String); override;
begin
  inherited;

  Self.BoundsFinder.CustomFunction := @Self.CustomBoundsFinder;
end;

var
  RootInterface: TRSRootInterface;

begin
  RootInterface.Setup('Root Interface');
end;
