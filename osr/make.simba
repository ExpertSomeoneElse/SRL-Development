{$DEFINE SRL_MAKE_INCLUDED}
{$IFNDEF SRL_OSR}
  {$I SRL/osr.simba}
{$ENDIF}

const
  MAKE_QUANTITY_ALL = -1;

type
  TRSMake = record(TRSInterface)
    Items: array of record 
      Item: String;
      Index: Int32;
    end;
  end;

{$i elements/make.elements}

function TRSMake.GetItemBoxes: TBoxArray;
var
  TPA: TPointArray;
  ATPA: T2DPointArray;
begin
  if SRL.FindColors(TPA, CTS1(591880, 30), Self.Bounds) > 0 then
  begin
    ATPA := TPA.Cluster(3);
    ATPA.FilterByDimensions(0, 20,60);
  end;

  Result := ATPA.Bounds();
end;

function TRSMake.IsOpen: Boolean;
begin
  Result := Self.ElementFindText(ERSMakeElement.QUANTITY_5, [RSColors.TEXT_WHITE, RSColors.TEXT_BROWN], 'All', RS_FONT_PLAIN_11);
end;

function TRSMake.SetQuantity(Amount: Int32): Boolean;
var
  Text: String;
  Element: ERSMakeElement;
begin
  Text := ToString(Amount);
  if (Amount = MAKE_QUANTITY_ALL) then
    Text := 'All';

  // Already enabled
  for Element in ERSMakeElement do
    if Self.ElementFindText(Element, [RSColors.TEXT_WHITE], Text, RS_FONT_PLAIN_11) then
      Exit(True);

  // Enable
  for Element in ERSMakeElement do
    if Self.ElementFindText(Element, [RSColors.TEXT_BROWN], Text, RS_FONT_PLAIN_11) then
    begin
      Self.ElementClick(Element);

      Exit(True);
    end;

  // Custom amount
  for Element in ERSMakeElement do
    if Self.ElementFindText(Element, [RSColors.TEXT_BROWN], 'X', RS_FONT_PLAIN_11) then
    begin
      Self.ElementClick(Element);

      Result := Chat.AnswerQuery('Enter amount', ToString(Amount), 3000);
      Exit;
    end;
end;

function TRSMake.SelectHelper(Boxes: TBoxArray; Index: Integer; UseKeyboard: Boolean = True): Boolean;

  function GetKey(B: TBox): Integer;
  begin
    if (Length(Boxes) = 1) then
      Exit(VK_SPACE);

    B.Y1 := B.Y2;
    B.Y2 := B.Y2 + 15;

    case OCR.Recognize(B, TOCRColorFilter.Create([RSColors.TEXT_BROWN]), RS_FONT_PLAIN_11) of
      'Space': Result := VK_SPACE;
      '0':     Result := VK_0;
      '1':     Result := VK_1;
      '2':     Result := VK_2;
      '3':     Result := VK_3;
      '4':     Result := VK_4;
      '5':     Result := VK_5;
      '6':     Result := VK_6;
      '7':     Result := VK_7;
      '8':     Result := VK_8;
      '9':     Result := VK_9;
      else
        Result := VK_UNKNOWN;
    end;
  end;

var
  Key: Integer;
begin
  Result := InRange(Index, Low(Boxes), High(Boxes));

  if Result then
  begin
    if UseKeyboard then
    begin
      Key := GetKey(Boxes[Index]);
      if (Key <> VK_UNKNOWN) then
      begin
        Keyboard.PressKey(Key);

        Exit;
      end;
    end;

    Mouse.Click(Boxes[Index], MOUSE_LEFT);
  end;
end;

function TRSMake.Select(Index: Int32; Quantity: Int32; UseKeyboard: Boolean = True): Boolean; overload;
begin
  if Self.SetQuantity(Quantity) then
    Result := Self.SelectHelper(Self.GetItemBoxes(), Index, UseKeyboard);
end;

function TRSMake.Select(Item: String; Quantity: Int32; UseKeyboard: Boolean = True): Boolean; overload;

  function IsHint(Text: String): Boolean;
  var
    TPA: TPointArray;
  begin
    if WaitUntil(FindColors(TPA, $A0FFFF, Self.Bounds()), SRL.TruncatedGauss(50, 2000), 3500) then
      Result := SameText(Text, OCR.Recognize(TPA.Bounds(), TOCRColorFilter.Create([0]), RS_FONT_PLAIN_12));
  end;

var
  I: Integer;
  Boxes: TBoxArray;
begin
  if Self.SetQuantity(Quantity) then
  begin
    Boxes := Self.GetItemBoxes();

    for I := 0 to High(Boxes) do
    begin
      Mouse.Move(Boxes[I]);

      if IsHint(Item) then
      begin
        Result := Self.SelectHelper(Boxes, I, UseKeyboard);

        Exit;
      end;
    end;
  end;
end;

procedure TRSMake.Draw(Bitmap: TMufasaBitmap); override;
begin
  if not Self.IsOpen then
    Exit;

  inherited;

  Bitmap.DrawBoxArray(Self.GetItemBoxes(), False, $0000FF);
end;

procedure TRSMake.Setup(Name: String); override;
begin
  inherited;

  // No offsets needed
  Self.BoundsFinder.Alignments := Chat.BoundsFinder.Alignments;
end;

var
  Make: TRSMake;

begin
  Make.Setup('Make');
end;
