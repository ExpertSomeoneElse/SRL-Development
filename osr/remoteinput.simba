{$loadlib ../resources/libremoteinput}

type
  TRemoteInput = record(TSRLBaseRecord)
  class const
    LIB_PATH = {$libpath ../resources/libremoteinput};
  var
    Image: TMufasaBitmap;
    EIOS: Pointer;
    PID: Int32;
  end;

procedure TRemoteInput.Setup;
begin
  Self.Name := 'Remote Input';

  {$IFNDEF SIMBAHEADLESS}
  if (Self.PID = 0) then
    Self.PID := GetSimbaTargetPID();
  if (not IsProcessRunning(Self.PID)) then
    Self.PID := 0;
  {$ENDIF}
  
  try
    if (Self.PID = 0) then
    begin
      if (MessageDlg('SRL', 'Automatically try to find a RS client?', mtConfirmation, [mbYes, mbNo]) = mrNo) then
        raise 'No RS clients found';
      
      Self.PID := RIInject(['JagexLauncher.exe', 'java']);
    end else
      RIInject(Self.PID);

    {$IFDEF CPU64}
    if not IsProcess64Bit(Self.PID) then
      raise 'Simba and OSRS must be the same bitness. Currently Simba is 64 bit and OSRS is 32 bit.';
    {$ENDIF}

    {$IFDEF CPU32}
    if IsProcess64Bit(Self.PID) then
      raise 'Simba and OSRS must be the same bitness. Currently Simba is 32 bit and OSRS is 64 bit.';
    {$ENDIF}
  
    Self.EIOS := EIOS_PairClient(Self.PID);
    if (Self.EIOS <> nil) then
      SetEIOSTarget(LIB_PATH, ToString(Self.PID));
  except
    Self.Fatal(GetExceptionMessage());
  end;
end;

function TRemoteInput.IsSetup: Boolean;
begin
  Result := (Self.PID > 0);
end;

function TRemoteInput.GetImage: TMufasaBitmap;
begin
  if (Self.Image = nil) then
  begin
    EIOS_SetGraphicsDebugging(Self.EIOS, True);
      
    Self.Image.Init();
    Self.Image.SetPersistentMemory(
       PtrUInt(EIOS_GetDebugImageBuffer(Self.EIOS)),
       GetClientBounds().Width(), GetClientBounds().Height()
    );
    
    Self.Image.Clear();
  end;
  
  Result := Self.Image;
end;

procedure TRemoteInput.LoseFocus;
var
  Space: TBoxArray;
begin
  Space := GetClientBounds().Expand(50).Invert(GetClientBounds().Expand(1000));

  if (Length(Space) > 0) then
  begin
    Mouse.CanIdle := False;
    Mouse.Click(Space[Random(Length(Space))], MOUSE_LEFT);
    Mouse.CanIdle := True;
  end;
end;

function EIOS_GetClientPIDs: TIntegerArray;
var
  I: Int32;
begin
  for I := 0 to EIOS_GetClients(True) - 1 do
    Result += EIOS_GetClientPID(I); 
end;

function EIOS_PairClient(Pid: Int32): Pointer; override;
begin
  Result := inherited();
  if (Result = nil) then
    raise 'Failed to pair client';
end;

procedure RIInject(PID: Int32); override;
begin
  inherited();

  if (not WaitUntil(Contains(PID, EIOS_GetClientPIDs()), 100, 1000)) then
    raise 'Failed to inject into PID ' + ToString(PID);
end;

function RIInject(ProcessNames: TStringArray): Integer; overload;
var
  I: Integer;
begin
  for I := 0 to High(ProcessNames) do
    RIInject(ProcessNames[I]);
  
  if (not WaitUntil(Length(EIOS_GetClientPIDs()) > 0, 100, 1000)) then
    raise 'Failed to inject into "' + ToString(ProcessNames) + '"'; 
    
  Result := EIOS_GetClientPIDs()[0];
end;
