(*
Bank
====
Methods to interact with the Bank.
*)

{$DEFINE SRL_BANK_INCLUDED}
{$IFNDEF SRL_OSR}
  {$I SRL/osr.simba}
{$ENDIF}

type
  ERSBankLocation = (
    CASTLE_WARS,
    FEROX,
    GRAND_EXCHANGE,
    FALADOR_EAST
  );

  TRSBankWithdrawItem = record
  class const
    QUANTITY_ALL         = -1;
    QUANTITY_ALL_BUT_ONE = -2;
  var
    Item: TRSItem;
    Quantity: Int32;
    Noted: Boolean;

    SetScrollPosition: Boolean;
    ScrollPosition: Integer;

    SetTabIndex: Boolean;
    TabIndex: Integer;
  end;
  
  TRSBankWithdrawSlot = record
  class const
    QUANTITY_ALL         = -1;
    QUANTITY_ALL_BUT_ONE = -2;
  var
    Slot: Int32;
    Quantity: Int32;
    Noted: Boolean;
  end;
  
  TRSBankDepositItem = record
  class const
    QUANTITY_ALL         = -1;
   var
    Item: TRSItem;
    Quantity: Int32;
  end;
  
  TRSBankDepositSlot = record
  class const
    QUANTITY_ALL         = -1;
  var
    Slot: Int32;
    Quantity: Int32;
  end;
  
  TRSBank = type TRSInterface;

{$i elements/bank.elements}

function TRSBank.GetItemArea: TBox;
begin
  Result := Self.Bounds;
  Result.X1 += 57;
  Result.Y1 += 77;
  Result.X2 -= 62;
  Result.Y2 -= 43;
end;

function TRSBank.GetSlotBoxes: TBoxArray; 
begin
  with Self.GetItemArea() do
    Result := Grid(8, Height() div 35, 31, 31, [17, 5], [X1, Y1]);
end;

function TRSBank.GetTabBox(TabIndex: Int32): TBox;
var
  Element: ERSBankElement;
begin
  Element := ERSBankElement(ERSBankElement.TAB_ALL + TabIndex);
  if not (Element in [ERSBankElement.TAB_ALL..ERSBankElement.TAB_9]) then
    Self.Fatal('Invalid tab index');

  Result := Self.ElementBounds(Element);
end;

function TRSBank.HasItems: Boolean;
begin
  Result := SRL.CountColor(RSColors.ITEM_BORDER, Self.GetItemArea()) > 0;
end;

(*
Bank.IsOpen
~~~~~~~~~~~
.. pascal:: function TRSBank.IsOpen(WaitForItems: Boolean = True): Boolean;

Returns true if the Bank is visible.
*)
function TRSBank.IsOpen: Boolean; overload;
begin
  Result := Self.IsTitle('Bank') or Self.IsTitle('Tab') or Self.IsTitle('Equip');
end;

function TRSBank.IsOpen(WaitTime: Integer): Boolean; overload;
begin
  Result := WaitUntil(Self.IsOpen(), SRL.TruncatedGauss(50, 1500), WaitTime);
end;

function TRSBank.Close: Boolean;
begin
  Result := Self.ClickCloseButton() and WaitUntil(not Self.IsOpen(), SRL.TruncatedGauss(50, 1500), 3000);
end;

procedure TRSBank.Draw(Bitmap: TMufasaBitmap); override;
begin
  if not Self.IsOpen() then
    Exit;

  inherited;

  Bitmap.DrawBoxes(Self.GetSlotBoxes(), False, $00FFFF);
end;

function TRSBank.FindItemBoundaries: TBoxArray;
var
  TPA: TPointArray;
  ATPA: T2DPointArray;
  Area, B: TBox;
begin
  Area := Self.GetItemArea();

  if SRL.FindColors(TPA, RSColors.ITEM_BORDER, Area) > 0 then
  begin
    ATPA := TPA.Cluster(50, 3);

    for B in ATPA.Bounds() do
    begin
      if B.Height() <= 5 then
        Continue;

      Result += Grid(8, 1, 32, B.Height(), [16], [Area.X1, B.Y1 - 1]);
    end;
  end;
end;

procedure TRSBank.Setup(Name: String); override;
begin
  inherited;

  with Self.BoundsFinder.Alignments[ERSClientMode.FIXED] do
  begin
    Left   := [@InterfaceArea.X1];
    Right  := [@InterfaceArea.X2];
    Top    := [@InterfaceArea.Y1, 2];
    Bottom := [@InterfaceArea.Y2, -1];

    Center.MaxWidth := 488;
    Center.MaxHeight := 800;
  end;

  with Self.BoundsFinder.Alignments[ERSClientMode.RESIZABLE_CLASSIC] do
  begin
    Left   := [@InterfaceArea.X1];
    Right  := [@InterfaceArea.X2];
    Top    := [@InterfaceArea.Y1, 2];
    Bottom := [@InterfaceArea.Y2, -2];

    Center.MaxWidth := 488;
    Center.MaxHeight := 800;
  end;

  // Same as above
  with Self.BoundsFinder.Alignments[ERSClientMode.RESIZABLE_MODERN] do
  begin
    Left   := [@InterfaceArea.X1];
    Right  := [@InterfaceArea.X2];
    Top    := [@InterfaceArea.Y1, 2];
    Bottom := [@InterfaceArea.Y2, -2];

    Center.MaxWidth := 488;
    Center.MaxHeight := 800;
  end;

  Self.ItemFinder.GetSearchBoxesFunction := @Self.FindItemBoundaries;
end;

function TRSBank.IsSearching: Boolean;
begin
  Result := Self.IsTitle('Showing items');
end;

function TRSBank.HasSearchQuery: Boolean;
begin
  Result := 'Show items' in Chat.GetQuery(); // todo method?
end;

function TRSBank.OpenSearchQuery: Boolean;
begin
  if Self.HasSearchQuery() then
    Exit(True);

  if Self.IsSearching() then
  begin
    Self.ElementClick(ERSBankElement.SEARCH);

    Wait(0, 1500, wdLeft);
  end;

  Self.ElementClick(ERSBankElement.SEARCH);
end;

function TRSBank.CloseSearch: Boolean;
begin
  if not Self.IsSearching() then
    Exit(True);

  Self.ElementClick(ERSBankElement.SEARCH);

  Result := WaitUntil(not Self.IsSearching(), 100, SRL.TruncatedGauss(1000, 2000));
end;

(*
Bank.Search
~~~~~~~~~~~
.. pascal:: function TRSBank.Search(Item: String): Boolean;

Searches for an item.

Example
-------

  Bank.Search('logs'); // Search for logs
*)
function TRSBank.Search(Item: String): Boolean; 
begin
  if Self.IsTitle('Showing items: ' + LowerCase(Item)) then
    Exit(True);

  Result := Self.OpenSearchQuery() and Chat.AnswerQuery('Show items', Item, Random(2000, 2500)) and
            Self.IsTitle('Showing items: ' + LowerCase(Item), Random(2000, 2500));
end;

function TRSBank.Open(P: TPoint): Boolean;
begin
{
  Mouse.Move(P);

  Result := ChooseOption.IsOpen() and ChooseOption.Select(Self.FINDER_OPTION);

  if not Result then
  begin
    if MainScreen.IsUpText(Self.FINDER_UPTEXT) then
    begin
      if ('Banker' in MainScreen.GetUpText()) or SRL.Dice(10) then
        Result := ChooseOption.Select(Self.FINDER_OPTION)
      else
      begin
        Mouse.Click(MOUSE_LEFT);

        Result := MainScreen.DidRedClick();
      end;
    end;
  end;

  if Result then
  begin
    if Minimap.HasFlag(Random(200, 400)) then
      Minimap.WaitFlag();

    Result := Self.IsOpen(3500);
  end;
}
end;

function TRSBank.DepositHelper(B: TBox; Amount: Int32; UseQuantityButtons: Boolean): Boolean;

  // Not a quantity button: 1,5,10,X,All
  function IsCustomQuantity(Quantity: Int32): Boolean;
  begin
    Result := not (Quantity in [1,5,10,TRSBankDepositItem.QUANTITY_ALL]);
  end;

var
  Element: ERSBankElement;
begin
  if UseQuantityButtons then
  begin
    if IsCustomQuantity(Amount) then
    begin
      if Self.ElementToggle(ERSBankElement.QUANTITY_X, RSColors.BUTTON_RED, 5, 5) then
      begin
        Mouse.Move(B);
      
        if MainScreen.IsUpText('Deposit-' + ToString(Amount)) then
        begin
          Mouse.Click(MOUSE_LEFT);
          
          Result := True;
        end else
          Result := ChooseOption.Select('Deposit-X') and Chat.AnswerQuery('Enter amount', ToString(Amount), Random(2000, 4000));
      end;
    end else
    begin
      case Amount of
        1:  Element := ERSBankElement.QUANTITY_1;
        5:  Element := ERSBankElement.QUANTITY_5;
        10: Element := ERSBankElement.QUANTITY_10;
        else 
          Element := ERSBankElement.QUANTITY_ALL;
      end;

      Result := Self.ElementToggle(Element, RSColors.BUTTON_RED, 5, 5);
      if Result then
        Mouse.Click(B, MOUSE_LEFT);
    end;
  end else
  begin
    Mouse.Move(B);

    if (Amount = TRSBankDepositItem.QUANTITY_ALL) then
      Result := ChooseOption.Select('Deposit-All')
    else
      Result := ChooseOption.Select('Deposit-' + ToString(Amount) + ' ', MOUSE_LEFT, True, False) or
                ChooseOption.Select('Deposit-X') and Chat.AnswerQuery('Enter amount', ToString(Amount), Random(2000, 2500));
  end;
end;  
  
function TRSBank.WithdrawHelper(B: TBox; Amount: Int32; Noted: Boolean; UseQuantityButtons: Boolean): Boolean;

  // Not a quantity button: 1,5,10,X,All
  function IsCustomQuantity(Quantity: Int32): Boolean;
  begin
    Result := not (Quantity in [1,5,10,TRSBankWithdrawItem.QUANTITY_ALL]);
  end;

var
  Element: ERSBankElement;
begin
  if Noted then
    Element := ERSBankElement.NOTE
  else
    Element := ERSBankElement.ITEM;

  if Self.ElementToggle(Element, RSColors.BUTTON_RED, 5, 5) then
  begin
    if UseQuantityButtons then
    begin
      if IsCustomQuantity(Amount) then
      begin
        if Self.ElementToggle(ERSBankElement.QUANTITY_X, RSColors.BUTTON_RED, 0, 5) then
        begin
          Mouse.Move(B);

          if MainScreen.IsUpText('Withdraw-' + ToString(Amount)) then
          begin
            Mouse.Click(MOUSE_LEFT);

            Result := True;
          end else
            Result := ChooseOption.Select('Withdraw-X') and Chat.AnswerQuery('Enter amount', ToString(Amount), Random(2000, 4000));
        end;
      end else
      begin
        case Amount of
          1:  Element := ERSBankElement.QUANTITY_1;
          5:  Element := ERSBankElement.QUANTITY_5;
          10: Element := ERSBankElement.QUANTITY_10;
          else
            Element := ERSBankElement.QUANTITY_ALL;
        end;

        Result := Self.ElementToggle(Element, RSColors.BUTTON_RED, 5, 5);
        if Result then
          Mouse.Click(B, MOUSE_LEFT);
      end;
    end else
    begin
      Mouse.Move(B);

      case Amount of
        TRSBankWithdrawItem.QUANTITY_ALL:
          Result := ChooseOption.Select('Withdraw-All');
        TRSBankWithdrawItem.QUANTITY_ALL_BUT_ONE:
          Result := ChooseOption.Select('Withdraw-All-but-1');
        else
          Result := ChooseOption.Select('Withdraw-' + ToString(Amount) + ' ', MOUSE_LEFT, True, False) or
                    ChooseOption.Select('Withdraw-X') and Chat.AnswerQuery('Enter amount', ToString(Amount), Random(2000, 2500));
      end;
    end;
  end;
end;


(*
Bank.CountTabs
~~~~~~~~~~~
.. pascal:: function TRSBank.CountTabs: Int32;

Counts the existing bank tabs.

Example
-------

  WriteLn Bank.CountTabs;
*)
function TRSBank.CountTabs: Int32;
var
  i: Integer;
  TPA: TPointArray;
begin
  Result := 0;

  for i := 9 downto 1 do
    if SRL.FindColors(TPA, CTS0(65536), Self.GetTabBox(i)) > 0 then
      Exit(i);
end;

(*
Bank.GetCurrentTab
~~~~~~~~~~~
.. pascal:: function TRSBank.GetCurrentTab: Int32;

Get the current active bank tab.

Example
-------

  WriteLn Bank.GetCurrentTab;
*)
function TRSBank.GetTabIndex: Int32;
var
  Element: ERSBankElement;
  Box: TBox;
begin
  for Element in [ERSBankElement.TAB_ALL..ERSBankElement.TAB_9] do
  begin
    Box := Self.ElementBounds(Element);
    Box.Y1 := Box.Y2;
    if CountColor($232B2E, Box) = 0 then
      Exit;

    Inc(Result);
  end;

  Result := -1;
end;

function TRSBank.IsTabIndex(Index: Integer): Boolean;
begin
  Result := (Self.GetTabIndex() = Index);
end;

(*
Bank.OpenTab
~~~~~~~~~~~
.. pascal:: function TRSBank.OpenTab(Tab: Int32): Boolean;

Open the specified bank tab.

Example
-------

  Bank.OpenTab(0);
*)
function TRSBank.SetTabIndex(TabIndex: Int32): Boolean;
var
  Element: ERSBankElement;
begin
  if not Self.IsOpen() then
    Exit;

  if Self.IsTabIndex(TabIndex) then
    Exit(True);

  Element := ERSBankElement(ERSBankElement.TAB_ALL + TabIndex);
  if not (Element in [ERSBankElement.TAB_ALL..ERSBankElement.TAB_9]) then
    Self.Fatal('Invalid tab index');

  Self.ElementClick(Element);

  Result := WaitUntil(Self.IsTabIndex(TabIndex), SRL.TruncatedGauss(50, 1500), 3000);
end;

function TRSBank.FindItem(Item: TRSItem; out Box: TBox): Boolean;
begin
  Result := Self.ItemFinder.Find(Item, Box);
end;

function TRSBank.Contains(Item: TRSItem): Boolean;
begin
  Result := Self.ItemFinder.Contains(Item);
end;

function TRSBank.ContainsAny(Items: TRSItemArray): Boolean;
begin
  Result := Self.ItemFinder.ContainsAny(Items);
end;

function TRSBank.CountStack(Item: TRSItem): Integer;
begin
  Result := Self.ItemFinder.CountStack(Item);
end;

(*
Bank.WithdrawItem
~~~~~~~~~~~~~~~~~
.. pascal:: function TRSBank.WithdrawItem(Item: TRSBankWithdrawItem; UseQuantityButtons: Boolean): Boolean;

Finds and withdraws an item.

Parameters
----------

Item
	TRSBankWithdrawItem variable to withdraw.

UseQuantityButtons  
  Determines if to use the 1,5,10,X,ALL `Quantity` buttons.

Example
-------

  var
    ItemToWithdraw: TRSBankWithdrawItem;
    
  ItemToWithdraw.Item := 'Iron full helm'; 
  ItemToWithdraw.Quantity := 5;
  ItemToWithdraw.Noted := False;  
  
  Bank.WithdrawItem(ItemToWithdraw, True);  
  
  // OR you can shorthand by passing an open array.
  
  Bank.WithdrawItem(['Iron full helm', 5, False], True);  
*)
function TRSBank.WithdrawItem(Item: TRSBankWithdrawItem; UseQuantityButtons: Boolean): Boolean; 
var
  Box: TBox;
begin
  if Self.FindItem(Item.Item, Box) then
  begin
    Result := Self.WithdrawHelper(Box, Item.Quantity, Item.Noted, UseQuantityButtons);
    Exit;
  end;

  if Item.SetTabIndex then
    Self.SetTabIndex(Item.TabIndex);
  if Item.SetScrollPosition then
    Self.SetScrollPosition(Item.ScrollPosition);

  if (Item.SetTabIndex or Item.SetScrollPosition) then
  begin
    if Self.FindItem(Item.Item, Box) then
      Result := Self.WithdrawHelper(Box, Item.Quantity, Item.Noted, UseQuantityButtons);
  end;
end;

function TRSBank.WithdrawSlot(Item: TRSBankWithdrawSlot; UseQuantityButtons: Boolean): Boolean;
begin
  Result := Self.WithdrawHelper(Self.GetSlotBoxes()[Item.Slot], Item.Quantity, Item.Noted, UseQuantityButtons);
end;

function TRSBank.DepositItem(Item: TRSBankDepositItem; UseQuantityButtons: Boolean): Boolean;
var
  B: TBox;
begin
  //if Inventory.FindItem(Item.Item, B) then
  //  Result := Self.DepositHelper(B, Item.Quantity, UseQuantityButtons);
end;

function TRSBank.DepositSlot(Item: TRSBankDepositSlot; UseQuantityButtons: Boolean): Boolean; 
begin
  Result := Self.DepositHelper(Inventory.GetSlotBox(Item.Slot), Item.Quantity, UseQuantityButtons);
end;

(*
Bank.DepositAll
~~~~~~~~~~~~~~~
.. pascal:: function TRSBank.DepositAll: Boolean;

Depositis your inventory by clicking the deposit inventory button
*)
function TRSBank.DepositAll: Boolean;
begin
  if (Inventory.Count() = 0) then
    Exit(True);

  Result := Self.IsOpen();
  if Result then
    Self.ElementClick(ERSBankElement.DEPOSIT_INVENTORY);
end;

(*
var Bank
~~~~~~~~
  Global Bank variable.
*)
var
  Bank: TRSBank;

begin
  Bank.Setup('Bank');
end;

(*
GameTabs.Open
~~~~~~~~~~~~~
.. pascal:: function TRSGameTabs.GetCurrentTab: ERSGametab; override;

Overrides **GameTabs.GetCurrentTab** to return the inventory tab if bank is open.
*)
function TRSGameTabs.GetCurrentTab: ERSGametab; override;
begin
  Result := inherited;

  if (Result = ERSGameTab.UNKNOWN) and Bank.IsOpen() then
    Result := ERSGameTab.INVENTORY;
end;

(*
GameTabs.Open
~~~~~~~~~~~~~
.. pascal:: function TRSGameTabs.Open(Tab: ERSGameTab): Boolean; override;

Overrides **GameTabs.Open** to close the bank if the bank is open.
*)

function TRSGameTabs.Open(Tab: ERSGameTab): Boolean; override;
begin
  if (Tab = ERSGameTab.INVENTORY) and Bank.IsOpen() then
    Bank.Close();

  Result := inherited();
end;

