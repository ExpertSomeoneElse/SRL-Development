{$DEFINE SRL_LOGOUT_INCLUDED}
{$IFNDEF SRL_OSR}
  {$I SRL/osr.simba}
{$ENDIF}

type
  TRSLogout = type TRSInterface;

{$I elements/logout.elements}

procedure TRSLogout.SetupAlignment(Mode: ERSClientMode); override;
begin 
  inherited;
  
  Self.Alignment.Left := [@GameTab.X1, -3];
  Self.Alignment.Right := [@GameTab.X2, 3];
  Self.Alignment.Top := [@GameTab.Y1];
  Self.Alignment.Bottom := [@GameTab.Y2];
end;

function TRSLogout.IsOpen: Boolean;
begin
  Result := (GameTabs.GetCurrentTab() = ERSGameTab.LOGOUT);
end;

function TRSLogout.Open: Boolean;
begin
  Result := GameTabs.Open(ERSGameTab.LOGOUT);
end;

function TRSLogout.IsWorldSwitcherOpen: Boolean;
begin
  Result := Self.IsOpen() and Self.ElementFindText(ERSLogoutElement.CURRENT_WORLD, [Self.COLOR_TEXT_ORANGE], 'Current world', RS_FONT_BOLD_12);
end;

function TRSLogout.CloseWorldSwitcher: Boolean;
begin
  if Self.IsOpen() and (not Self.IsWorldSwitcherOpen()) then
    Exit(True);

  Self.ElementClick(ERSLogoutElement.WORLD_SWITCHER_CLOSE);

  Result := WaitUntil(not Self.IsWorldSwitcherOpen(), 500, 5000);
end;

function TRSLogout.ClickLogout(Attempts: Int32 = 5; TryTime: Int32 = 20000): Boolean;
begin
  if (not Self.Open()) or (not Self.CloseWorldSwitcher()) then
    Exit;

  for 1 to Attempts do
  begin
    Self.ElementClick(ERSLogoutElement.LOGOUT);
    if WaitUntil(not RSClient.IsLoggedIn(), 500, (TryTime div Attempts) + SRL.NormalRange(-2000, 2000)) then
      Exit(True);
  end;
end;

var
  Logout: TRSLogout;

begin
  Logout.Setup('Logout', [@Logout.SetupAlignment, @Logout.Draw]);
end;
