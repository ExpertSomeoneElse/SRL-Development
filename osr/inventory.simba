(*
Inventory
=========
Methods to interact with the inventory.

.. note::

  Most methods will open the inventory.
*)

{$DEFINE SRL_INVENTORY_INCLUDED}
{$IFNDEF SRL_OSR}
  {$I SRL/osr.simba}
{$ENDIF}

const
  //Column wise and "reversed" column wise - normal pattern
  DROP_PATTERN_REGULAR: TIntegerArray = [0..27];
  DROP_PATTERN_REGULAR_R: TIntegerArray = [3,2,1,0, 7,6,5,4, 11,10,9,8, 15,14,13,12, 19,18,17,16, 23,22,21,20, 27,26,25,24];

  //Column wise snake and "reversed" version
  DROP_PATTERN_SNAKE: TIntegerArray  = [0,1,2,3, 7,6,5,4, 8,9,10,11, 15,14,13,12, 16,17,18,19, 23,22,21,20, 24,25,26,27];
  DROP_PATTERN_SNAKE_R: TIntegerArray = [3,2,1,0, 4,5,6,7, 11,10,9,8, 12,13,14,15, 19,18,17,16, 20,21,22,23, 27,26,25,24];

  //by row (and "reversed")
  DROP_PATTERN_TOPDOWN: TIntegerArray = [0,4,8,12,16,20,24,  1,5,9,13,17,21,25,  2,6,10,14,18,22,26, 3,7,11,15,19,23,27];
  DROP_PATTERN_TOPDOWN_R: TIntegerArray = [3,7,11,15,19,23,27, 2,6,10,14,18,22,26, 1,5,9,13,17,21,25,  0,4,8,12,16,20,24];

  //Spiral pattern: Starts in slot 0(top left corner of invy) and circles in a clockwise spiral
  DROP_PATTERN_SPIRAL: TIntegerArray   = [0,1,2,3, 7,11,15,19,23, 27,26,25,24, 20,16,12,8,4, 5, 6,10,14,18,22, 21,17,13,9];

type
  TRSInventory = record(TRSGameTab)
  class const
    LOW_SLOT  = 0;
    HIGH_SLOT = 27;
  var
    ItemBoxCache: record
      ClientWidth, ClientHeight: Integer;
      ClientMode: ERSClientMode;
      Boxes: TBoxArray;
    end;
  end;

(*
TRSInventory.CheckIndex
~~~~~~~~~~~~~~~~~~~~~~~
.. pascal:: procedure TRSInventory.CheckIndex(Index: Integer);

note: Raises a fatal error if the **Index** is not within 0..27

Example
-------

  Inventory.CheckIndex(5)
*)
procedure TRSInventory.CheckIndex(Index: Integer);
begin
  if not InRange(Index, Self.LOW_SLOT, Self.HIGH_SLOT) then
    Self.Fatal('Invalid inventory index: ' + ToString(Index));
end;

function TRSInventory.GetItemBoxes: TBoxArray; overload;
var
  W, H: Integer;
begin
  GetClientDimensions(W, H);
  if (ItemBoxCache.ClientMode = RSClient.ClientMode()) and (ItemBoxCache.ClientWidth = W) and (ItemBoxCache.ClientHeight = H) then
  begin
    Result := ItemBoxCache.Boxes;
    Exit;
  end;

  Result := Grid(4, 7, 31, 31, [11, 5], [Self.X1 + 13, Self.Y1 + 9]);

  ItemBoxCache := [W, H, RSClient.ClientMode, Result];
end;

function TRSInventory.GetItemBoxes(Indices: TIntegerArray): TBoxArray; overload;
var
  I: Integer;
begin
  SetLength(Result, Length(Indices));
  for I := 0 to High(Indices) do
    Result[I] := Self.GetItemBox(Indices[I]);
end;

function TRSInventory.GetItemBox(Index: Integer): TBox;
begin
  CheckIndex(Index);

  Result := Self.GetItemBoxes()[Index];
end;

(*
TRSInventory.GetItemBoxNearby
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.. pascal:: function TRSInventory.GetItemBoxNearby(Slot: Integer; Slots: TIntegerArray): TBox;

Example
-------

*)
function TRSInventory.GetItemBoxNearby(Slot: Integer; Slots: TIntegerArray): TBox;
begin
  Slots.Remove(Slot);
  if (Length(Slots) = 0) then
    Self.Fatal('RandomSlotNearby: No slots to choose from');

  Result := SRL.RandomBoxNearby(Self.GetItemBox(Slot).Middle, Self.GetItemBoxes(Slots));
end;

(*
TRSInventory.PointToBox
~~~~~~~~~~~~~~~~~~~~~~~
.. pascal:: function TRSInventory.PointToBox(P: TPoint): Integer;

Returns the inventory box index that contains the point **P**.
Returns -1 if the point is not in any box.

Example
-------

  P := Inventory.GetItemBox(5).Middle; // Example point
  WriteLn(Inventory.PointToSlot(P)); // 5
*)
function TRSInventory.PointToBox(P: TPoint): Integer;
var
  I: Integer;
  Boxes: TBoxArray;
begin
  Boxes := Self.GetItemBoxes();
  for I := 0 to High(Boxes) do
    if Boxes[I].Contains(P) then
      Exit(I);

  Result := -1;
end;

(*
TRSInventory.IsSelected
~~~~~~~~~~~~~~~~~~~~~~~
.. pascal:: function TRSInventory.IsSelected(Index: Integer): Boolean;

Returns True if the index is selected (white outline).

Example
-------

  if Inventory.IsSelected(1) then
    WriteLn('Inventory index 1 is selected');
*)
function TRSInventory.IsSelected(Index: Integer): Boolean;
var
  B: TBox;
begin
  if Self.LockGameTab() then
  try
    B := Self.GetItemBox(Index);
    B.Y1 += 8; // skip quantity

    Result := SRL.CountColor(RSColors.ITEM_BORDER_SELECTED, B) > 0;
  finally
    Self.UnlockGametab();
  end;
end;

(*
TRSInventory.IsUsed
~~~~~~~~~~~~~~~~~~~
.. pascal:: function TRSInventory.IsUsed(Index: Integer): Boolean;

Returns true if the *index* (0..27) contains an item.

Example
-------

  WriteLn(Inventory.IsUsed(25));
*)
function TRSInventory.IsUsed(Index: Integer): Boolean;
begin
  if Self.LockGameTab() then
  try
    Result := Self.IsSelected(Index) or (SRL.CountColor(CTS1(1118740, 35), Self.GetItemBox(Index)) > 0);
  finally
    Self.UnlockGametab();
  end;
end;

(*
TRSInventory.IsFull
~~~~~~~~~~~~~~~~~~~
.. pascal:: function TRSInventory.IsFull: Boolean;

Returns true if the inventory is full. (Count = 28)

Example
-------

  WriteLn(Inventory.IsFull());
*)
function TRSInventory.IsFull: Boolean;
var
  I: Integer;
begin
  if Self.LockGameTab() then
  try
    for I := Self.LOW_SLOT to Self.HIGH_SLOT do
      if not Self.IsUsed(I) then
        Exit(False);

    Result := True;
  finally
    Self.UnlockGametab();
  end;
end;

(*
TRSInventory.IsEmpty
~~~~~~~~~~~~~~~~~~~~
.. pascal:: function TRSInventory.IsEmpty: Boolean;

Returns true if the inventory is empty. (Count = 0)

Example
-------

  WriteLn(Inventory.IsEmpty());
*)
function TRSInventory.IsEmpty: Boolean;
var
  I: Integer;
begin
  if Self.LockGameTab() then
  try
    for I := Self.LOW_SLOT to Self.HIGH_SLOT do
      if Self.IsUsed(I) then
        Exit(False);

    Result := True;
  finally
    Self.UnlockGametab();
  end;
end;

(*
TRSInventory.GetSelected
~~~~~~~~~~~~~~~~~~~~~~~~
.. pascal:: function TRSInventory.GetSelected: Integer;

Returns the index of the selected item (white outline).
**-1** is returned if no item is selected.

Example
-------

  WriteLn(Inventory.GetSelected());
*)
function TRSInventory.GetSelected: Integer;
var
  I: Integer;
begin
  if Self.LockGametab() then
  try
    for I := Self.LOW_SLOT to Self.HIGH_SLOT do
      if Self.IsSelected(I) then
        Exit(I);

    Result := -1;
  finally
    Self.UnlockGametab();
  end;
end;

(*
TRSInventory.ClearSelected
~~~~~~~~~~~~~~~~~~~~~~~~~~
.. pascal:: function TRSInventory.ClearSelected: Boolean;

Unselects the currently selected item (white outline).

Example
-------

  if Inventory.ClearSelected() then
    WriteLn('No item is selected now.);
*)
function TRSInventory.ClearSelected: Boolean;
var
  Index: Integer;
begin
  if Self.LockGameTab() then
  try
    Index := Self.GetSelected();
    if (Index = -1) then
      Exit(True);

    Mouse.Click(Self.GetItemBox(Index), MOUSE_LEFT);

    Result := WaitUntil(Self.GetSelected() = -1, 100, SRL.TruncatedGauss(1000, 2000));
  finally
    Self.UnlockGametab();
  end;
end;

(*
TRSInventory.SetSelected
~~~~~~~~~~~~~~~~~~~~~~~~
.. pascal:: function TRSInventory.SetSelected(Index: Integer): Boolean;

Clicks the item index to "select" it (white outline).

Example
-------

  WriteLn(Inventory.SetSelected(2));
*)
function TRSInventory.SetSelected(Index: Integer): Boolean;
var
  Selected: Integer;
begin
  Self.CheckIndex(Index);

  if Self.LockGameTab() then
  try
    Selected := Self.GetSelected();
    if (Selected = Index) then
      Exit(True);
    if (Selected > -1) and (not Self.ClearSelected()) then
      Exit(False);

    Mouse.Click(Self.GetItemBox(Index), MOUSE_LEFT);

    Result := WaitUntil(Self.GetSelected() = Index, 100, SRL.TruncatedGauss(1000, 2000));
  finally
    Self.UnlockGametab();
  end;
end;

(*
TRSInventory.Use
~~~~~~~~~~~~~~~~
.. pascal:: function TRSInventory.Use(Slot, OtherSlot: Integer): Boolean; overload;

Uses an item on another.

Example
-------

  Inventory.Use(1, 2);
*)
function TRSInventory.Use(Slot, OtherSlot: Integer): Boolean; overload;
begin
  Self.CheckIndex(Slot);
  Self.CheckIndex(OtherSlot);

  if Self.LockGameTab() then
  try
    Result := Self.SetSelected(Slot);
    if Result then
      Mouse.Click(Self.GetItemBox(OtherSlot), MOUSE_LEFT);
  finally
    Self.UnlockGametab();
  end;
end;

function TRSInventory.RandomPattern: TIntegerArray;
var
  Patterns: T2DIntegerArray;
begin
  Patterns := [
    DROP_PATTERN_SNAKE, DROP_PATTERN_SPIRAL,
    DROP_PATTERN_REGULAR, DROP_PATTERN_TOPDOWN,
    DROP_PATTERN_SNAKE_R, DROP_PATTERN_TOPDOWN_R
  ];

  Result := Patterns[Random(0, High(Patterns))];
end;

function TRSInventory.ErrorPattern(Pattern: TIntegerArray=DROP_PATTERN_REGULAR; ErrorChance:Integer=5): TIntegerArray;
var i,j,h,k,tmp: Integer;
begin
  Result := Copy(Pattern);
  h := High(Pattern);
  i := 1;
  while i < h do
  begin
    if Random(100) < ErrorChance then
    begin
      case Random(0,2) of
        0:begin
            tmp := Result[i];
            for j:=i+1 to h do Result[j-1] := Result[j];
            Result[h] := tmp;
          end;
        1:begin
            Swap(Result[i+1],Result[i]);
          end;
        2:begin
            tmp := Result[i];
            k := Random(i+1,h);
            for j:=i+1 to k do Result[j-1] := Result[j];
            Result[k] := tmp;
          end;
      end;
    end;
    Inc(i);
  end;
end;

function TRSInventory.MakePattern(Slots: TIntegerArray; Pattern: TIntegerArray): TIntegerArray;
var
  I: Integer;
begin
  for I := 0 to High(Pattern) do
    if Slots.Contains(Pattern[I]) then
      Result += Pattern[I];
end;

function TRSInventory.ShiftDrop(Slots: TIntegerArray): Boolean;

  procedure Click(Index: Integer);
  var
    Circle: TCircle;
  begin
    if not IsKeyDown(VK_SHIFT) then
      KeyDown(VK_SHIFT);

    Mouse.Click(Self.GetItemBox(Index), MOUSE_LEFT);

    // Chance of a little spam click
    for 2 to SRL.TruncatedGauss(0, 5) do
    begin
      Wait(30, 160, wdLeft);

      Circle.X := Mouse.Position().X;
      Circle.Y := Mouse.Position().Y;
      Circle.Radius := 5;

      Mouse.Click(Circle, MOUSE_LEFT, True);
    end;

    if SRL.Dice(50) then
      Wait(0, 350, wdLeft);
  end;

  function Empty: Boolean;
  var
    I: Integer;
  begin
    for I := 0 to High(Slots) do
      if Self.IsUsed(Slots[I]) then
        Exit;

    Result := True;
  end;

  function Drop: Boolean;
  var
    I: Integer;
  begin
    for I := 0 to High(Slots) do
    begin
      if not Self.ClearSelected() then
        Break;

      if Self.IsUsed(Slots[I]) then
        Click(Slots[I]);
    end;

    Result := WaitUntil(Empty(), 100, SRL.TruncatedGauss(1000, 1500));
  end;

var
  Attempts: Integer;
begin
  if (Length(Slots) = 0) then
    Exit(True);

  ActivateClient();    // Without focus shift wont register
  IsKeyDown(VK_SHIFT); // Clear cache

  if Self.LockGameTab() then
  try
    for Attempts := 1 to 3 do
    begin
      if Drop() then
        Exit(True);

      Wait(500, 2000, wdLeft);
    end;
  finally
    if IsKeyDown(VK_SHIFT) then
      KeyUp(VK_SHIFT);

    Self.ClearSelected();
    Self.UnlockGametab();
  end;
end;

(*
TRSInventory.Count
~~~~~~~~~~~~~~~~~~
.. pascal:: function TRSInventory.Count: Integer;

Returns the number of items in the inventory.

Example
-------

  WriteLn('Currently ', Inventory.Count(), ' items in inventory);
*)
function TRSInventory.Count: Integer;
var
  I: Integer;
begin
  if Self.LockGameTab() then
  try
    for I := Self.LOW_SLOT to Self.HIGH_SLOT do
      if Self.IsUsed(I) then
        Result += 1;
  finally
    Self.UnlockGametab();
  end;
end;

function TRSInventory.WaitCount(Count: Integer; WaitTime: Integer; Interval: Integer = -1): Boolean;
begin
  if (Interval = -1) then
    Interval := SRL.TruncatedGauss(50, 1500);

  Result := WaitUntil(Self.Count() = Count, Interval, WaitTime);
end;

function TRSInventory.Use(Item, OtherItem: TRSItem): Boolean; overload;
var
  Slots, OtherSlots: TIntegerArray;
  Slot: Integer;
begin
  if Self.LockGameTab() then
  try
    Self.ClearSelected();

    Slots := Self.FindAll(Item);
    OtherSlots := Self.FindAll(OtherItem);
    if (Length(Slots) = 0) or (Length(OtherSlots) = 0) then
      Exit;

    Slot := Slots[Random(Length(Slots))];

    Result := Self.SetSelected(Slot);
    if Result then
      Mouse.Click(Self.GetItemBoxNearby(Slot, OtherSlots), MOUSE_LEFT);
  finally
    Self.UnlockGametab();
  end;
end;

function TRSInventory.ShiftDrop(Items: TRSItemArray; Pattern: TIntegerArray): Boolean; overload;
begin
  if Self.LockGameTab() then
  try
    Result := Self.ShiftDrop(Self.MakePattern(Self.FindAll(Items), Pattern));
  finally
    Self.UnlockGametab();
  end;
end;

function TRSInventory.Contains(Item: TRSItem): Boolean;
begin
  if Self.LockGameTab() then
  try
    Result := Self.ItemFinder.Contains(Item);
  finally
    Self.UnlockGametab();
  end;
end;

function TRSInventory.ContainsAny(Items: TRSItemArray): Boolean;
begin
  if Self.LockGameTab() then
  try
    Result := Self.ItemFinder.ContainsAny(Items);
  finally
    Self.UnlockGametab();
  end;
end;

function TRSInventory.ContainsAll(Items: TRSItemArray): Boolean;
begin
  if Self.LockGameTab() then
  try
    Result := Self.ItemFinder.ContainsAll(Items);
  finally
    Self.UnlockGametab();
  end;
end;

function TRSInventory.FindAll(Item: TRSItem): TIntegerArray; overload;
begin
  if Self.LockGameTab() then
  try
    Result := Self.ItemFinder.IndicesOf([Item]);
  finally
    Self.UnlockGametab();
  end;
end;

function TRSInventory.FindAll(Items: TRSItemArray): TIntegerArray; overload;
begin
  if Self.LockGameTab() then
  try
    Result := Self.ItemFinder.IndicesOf(Items);
  finally
    Self.UnlockGametab();
  end;
end;

function TRSInventory.Find(Item: TRSItem): Integer;
begin
  if Self.LockGameTab() then
  try
    Result := Self.ItemFinder.IndexOf([Item]);
  finally
    Self.UnlockGametab();
  end;
end;

function TRSInventory.CountStack(Item: TRSItem): Integer;
begin
  if Self.LockGameTab() then
  try
    Result := Self.ItemFinder.CountStack(Item);
  finally
    Self.UnlockGametab();
  end;
end;

function TRSInventory.Hover(Item: TRSItem): Boolean;
begin
  if Self.LockGameTab() then
  try
    Result := Self.ItemFinder.Hover(Item);
  finally
    Self.UnlockGametab();
  end;
end;

function TRSInventory.Click(Item: TRSItem): Boolean;
begin
  if Self.LockGameTab() then
  try
    Result := Self.ItemFinder.Click(Item);
  finally
    Self.UnlockGametab();
  end;
end;

function TRSInventory.ClickOption(Item: TRSItem; Option: String): Boolean;
begin
  if Self.LockGameTab() then
  try
    Result := Self.ItemFinder.ClickOption(Item, Option);
  finally
    Self.UnlockGametab();
  end;
end;

procedure TRSInventory.Draw(Bitmap: TMufasaBitmap); override;
begin
  if not Self.IsOpen() then
    Exit;

  inherited();

  Bitmap.DrawBoxArray(Self.GetItemBoxes(), False, $00FFFF);
end;

procedure TRSInventory.Setup(Name: String); override;
begin
  inherited;

  Self.ID := ERSGameTab.INVENTORY;
  Self.ItemFinder.GetSearchBoxesFunction := @Self.GetItemBoxes;
end;

var
  Inventory: TRSInventory;

begin
  Inventory.Setup('Inventory');
end;
