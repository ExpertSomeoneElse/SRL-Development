{$DEFINE SRL_INTERFACE_INCLUDED}
{$IFNDEF SRL_OSR}
  {$I SRL/osr.simba}
{$ENDIF}

type
  TRSInterfaceSetupMethod = procedure of object;
  TRSInterfaceDrawMethod = procedure(Bitmap: TMufasaBitmap) of object;
  TRSInterfaceSetupAlignmentMethod = procedure(Mode: ERSClientMode) of object;

var
  InterfaceSetupMethods: array of TRSInterfaceSetupMethod;
  InterfaceDrawMethods: array of TRSInterfaceDrawMethod;
  InterfaceSetupAlignmentMethods: array of TRSInterfaceSetupAlignmentMethod;

procedure RegisterInterface(
  Setup: TRSInterfaceSetupMethod;
  Draw: TRSInterfaceDrawMethod;
  SetupAlignment: TRSInterfaceSetupAlignmentMethod)
begin
  InterfaceSetupMethods += @Setup;
  InterfaceDrawMethods += @Draw;
  InterfaceSetupAlignmentMethods += @SetupAlignment;
end;

procedure SetupInterfaces;
var
  I: Integer;
begin
  for I:=0 to High(InterfaceSetupMethods) do
    InterfaceSetupMethods[I]();
end;

procedure SetupInterfaceAlignments(Mode: ERSClientMode);
var
  I: Integer;
begin
  for I:=0 to High(InterfaceSetupAlignmentMethods) do
    InterfaceSetupAlignmentMethods[I](Mode);
end;

procedure DebugInterfaces;
var
  Bitmap: TMufasaBitmap;
  I: Integer;
begin
  Freeze();

  try
    Bitmap.FromClient();

    for I:=0 to High(InterfaceDrawMethods) do
      InterfaceDrawMethods[I](Bitmap);

    Bitmap.Debug();
    Bitmap.Free();
  finally
    Unfreeze();
  end;
end;

type
  ERSInterfaceElementAnchor = (TOP, BOTTOM);

  TRSInterfaceElement = record
    Name: String;
    Anchor: ERSInterfaceElementAnchor;
    Offset: TPoint;
    Width, Height: Int32;
  end;

  TRSInterfaceAlignment = record
    Left, Right, Top, Bottom: record
      Method: function: Int32 of object;
      Offset: Int32;
    end;

    Center: record
      MaxWidth: Int32;
      MaxHeight: Int32;
    end;
  end;
  
  TRSInterface = record(TSRLBaseRecord)
  class const
    // Common text colors
    COLOR_TEXT_WHITE  = $FFFFFF;
    COLOR_TEXT_ORANGE = $1F98FF;

    // Common button colors
    COLOR_BUTTON_RED  = $2326A0; // enabled
    COLOR_BUTTON_GREY = $516370; // disabled
  var
    Mode: ERSClientMode;

    Elements: array of TRSInterfaceElement;

    Cache: record
      Enabled: Boolean;
    
      X1, Y1, X2, Y2: record
        Mode: ERSClientMode;
        ClientWidth, ClientHeight: Int32;
        Value: Int32;
      end;
    end;
    
    Alignment: TRSInterfaceAlignment;

    OnGetItemBoxes: function: TBoxArray of object;
  end;

{%codetools off}
function TRSInterface._ElementBounds(constref Element: TRSInterfaceElement): TBox;
var
  B: TBox;
begin
  B := Self.Bounds();

  case Element.Anchor of
    ERSInterfaceElementAnchor.TOP:
      begin
        Result.X1 := B.X1 + Element.Offset.X;
        Result.Y1 := B.Y1 + Element.Offset.Y;

        Result.X2 := Result.X1 + Element.Width-1; // fixme
        Result.Y2 := Result.Y1 + Element.Height-1;
      end;

    ERSInterfaceElementAnchor.BOTTOM:
      begin
        Result.X1 := B.X1 + Element.Offset.X;
        Result.Y2 := B.Y1 + Element.Offset.Y + B.Height;

        Result.X2 := Result.X1 + Element.Width-1;
        Result.Y1 := Result.Y2 - Element.Height-1;
      end;
  end;
end;

procedure TRSInterface._ElementClick(constref Element: TRSInterfaceElement; Button: Integer = MOUSE_LEFT); overload;
begin
  Mouse.Click(Self._ElementBounds(Element), Button);
end;

function TRSInterface._ElementClick(constref Element: TRSInterfaceElement; Option: String): Boolean; overload;
begin
  Mouse.Move(Self._ElementBounds(Element));

  Result := ChooseOption.Select(Option);
end;

function TRSInterface._ElementCountColor(constref Element: TRSInterfaceElement; Color, Tolerance: Integer): Integer;
begin
  Result := CountColorTolerance(Color, Self._ElementBounds(Element), Tolerance);
end;

function TRSInterface._ElementFindText(constref Element: TRSInterfaceElement; constref Colors: TIntegerArray; constref Text: String; constref Font: TFontSet): Boolean;
begin
  Result := OCR.LocateText(Self._ElementBounds(Element), Text, Font, TOCRColorRule.Create(Colors), 1);
end;

function TRSInterface._ElementToggle(constref Element: TRSInterfaceElement; Color, Tolerance: Integer; MinColorCount: Integer): Boolean;
begin
  if Self._ElementCountColor(Element, Color, Tolerance) > MinColorCount then
    Exit(True);

  Self._ElementClick(Element);

  Result := WaitUntil(Self._ElementCountColor(Element, Color, Tolerance) > MinColorCount, 50, SRL.TruncatedGauss(1000, 1500));
end;

function TRSInterface._ElementRecognizeNumber(constref Element: TRSInterfaceElement; constref Colors: TIntegerArray; constref Font: TFontSet): Int64;
begin
  Result := OCR.RecognizeNumber(Self._ElementBounds(Element), TOCRColorRule.Create(Colors), Font);
end;

function TRSInterface._ElementRecognizeText(constref Element: TRSInterfaceElement; constref Colors: TIntegerArray; constref Font: TFontSet): String;
begin
  Result := OCR.Recognize(Self._ElementBounds(Element), TOCRColorRule.Create(Colors), Font);
end;
{%codetools on}

function TRSInterface.FindItem(Item: TRSItem): TBoxArray; overload;
begin
  Result := ItemFinder.Find2(Item, Self.OnGetItemBoxes(), 1);
end;

function TRSInterface.FindItem(Item: TRSItem; out Match: TBox): Boolean; overload;
var
  Matches: TBoxArray;
begin
  Matches := ItemFinder.Find2(Item, Self.OnGetItemBoxes(), 1);

  Result := Length(Matches) > 0;
  if Result then
    Match := Matches[0];
end;

function TRSInterface.MouseItem(Item: TRSItem): Boolean;
var
  Match: TBox;
begin
  Result := Self.FindItem(Item, Match);
  if Result then
    Mouse.Move(Match);
end;

function TRSInterface.ClickItem(Item: TRSItem; Option: String): Boolean; overload;
begin
  if Self.MouseItem(Item) then
    Result := ChooseOption.Select([Option]);
end;

function TRSInterface.ClickItem(Item: TRSItem): Boolean; overload;
begin
  Result := Self.MouseItem(Item);
  if Result then
    Mouse.Click(MOUSE_LEFT);
end;

function TRSInterface.CountItem(Item: TRSItem): Int32;
begin
  Result := Length(Self.FindItem(Item));
end;

function TRSInterface.CountItemStack(Item: TRSItem): Int32;
var
  B: TBox;
begin
  if Self.FindItem(Item, B) then
    Result := SRL.GetItemAmount(B);
end;

procedure TRSInterface.Setup; 
begin
  Self.Name := 'Unnamed';
  Self.Cache.Enabled := True;
end;

procedure TRSInterface.SetupAlignment(Mode: ERSClientMode); 
begin
  Self.Mode := Mode;
end; 
  
function TRSInterface.X1: Int32;
var
  Left, Right, Width, Center: Single;
  ClientWidth, ClientHeight: Int32;
begin
  if Self.Cache.Enabled then
  begin
    GetClientDimensions(ClientWidth, ClientHeight);
    if (Self.Cache.X1.Mode = Self.Mode) and (Self.Cache.X1.ClientWidth = ClientWidth) and (Self.Cache.X1.ClientHeight = ClientHeight) then
      Exit(Self.Cache.X1.Value);
  end;
  
  if (@Self.Alignment.Left.Method = nil) then
    Self.Fatal('No left anchor');
    
  if (Self.Alignment.Center.MaxWidth > 0) then
  begin
    Left := Self.Alignment.Left.Method() + Self.Alignment.Left.Offset;
    Right := Self.Alignment.Right.Method() + Self.Alignment.Right.Offset;

    Width := (Right - Left);
    Center := Left + (Width / 2);

    Result := Max(
      Floor(Center - (Width / 2)),
      Floor(Center - ((Self.Alignment.Center.MaxWidth - 1) / 2))
    );
  end else
    Result := Round(Self.Alignment.Left.Method() + Self.Alignment.Left.Offset);
    
  if Self.Cache.Enabled then
    Self.Cache.X1 := [Self.Mode, ClientWidth, ClientHeight, Result];
end;

function TRSInterface.X2: Int32;
var
  Left, Right, Width, Center: Single;
  ClientWidth, ClientHeight: Int32;
begin
  if Self.Cache.Enabled then
  begin
    GetClientDimensions(ClientWidth, ClientHeight);
    if (Self.Cache.X2.Mode = Self.Mode) and (Self.Cache.X2.ClientWidth = ClientWidth) and (Self.Cache.X2.ClientHeight = ClientHeight) then
      Exit(Self.Cache.X2.Value);
  end;
    
  if (@Self.Alignment.Right.Method = nil) then
    Self.Fatal('No right anchor');
 
  if (Self.Alignment.Center.MaxWidth > 0) then
  begin
    Left := Self.Alignment.Left.Method() + Self.Alignment.Left.Offset;
    Right := Self.Alignment.Right.Method() + Self.Alignment.Right.Offset;

    Width := (Right - Left);
    Center := Left + (Width / 2);

    Result := Min(
      Floor(Center + (Width / 2)),
      Floor(Center + ((Self.Alignment.Center.MaxWidth - 1) / 2))
    );
  end else
    Result := Round(Self.Alignment.Right.Method() + Self.Alignment.Right.Offset);
  
  if Self.Cache.Enabled then  
    Self.Cache.X2 := [Self.Mode, ClientWidth, ClientHeight, Result];
end;

function TRSInterface.Y1: Int32;
var
  Top, Bottom, Height, Center: Single;
  ClientWidth, ClientHeight: Int32;
begin
  if Self.Cache.Enabled then
  begin
    GetClientDimensions(ClientWidth, ClientHeight);
    if (Self.Cache.Y1.Mode = Self.Mode) and (Self.Cache.Y1.ClientWidth = ClientWidth) and (Self.Cache.Y1.ClientHeight = ClientHeight) then
      Exit(Self.Cache.Y1.Value);
  end;
   
  if (@Self.Alignment.Top.Method = nil) then
    Self.Fatal('No top anchor');

  if (Self.Alignment.Center.MaxHeight > 0) then
  begin
    Top := Self.Alignment.Top.Method() + Self.Alignment.Top.Offset;
    Bottom := Self.Alignment.Bottom.Method() + Self.Alignment.Bottom.Offset;

    Height := (Bottom - Top);
    Center := Top + (Height / 2);

    Result := Max(
      Floor(Center - (Height / 2)),
      Floor(Center - ((Self.Alignment.Center.MaxHeight - 1) / 2))
    );
  end else
    Result := Round(Self.Alignment.Top.Method() + Self.Alignment.Top.Offset);
   
  if Self.Cache.Enabled then  
    Self.Cache.Y1 := [Self.Mode, ClientWidth, ClientHeight, Result];
end;

function TRSInterface.Y2: Int32;
var
  Top, Bottom, Height, Center: Single;
  ClientWidth, ClientHeight: Int32;
begin
  if Self.Cache.Enabled then
  begin
    GetClientDimensions(ClientWidth, ClientHeight);
    if (Self.Cache.Y2.Mode = Self.Mode) and (Self.Cache.Y2.ClientWidth = ClientWidth) and (Self.Cache.Y2.ClientHeight = ClientHeight) then
      Exit(Self.Cache.Y2.Value);
  end;
    
  if (@Self.Alignment.Bottom.Method = nil) then
    Self.Fatal('No bottom anchor');

  if (Self.Alignment.Center.MaxHeight > 0) then
  begin
    Top := Self.Alignment.Top.Method() + Self.Alignment.Top.Offset;
    Bottom := Self.Alignment.Bottom.Method() + Self.Alignment.Bottom.Offset;

    Height := (Bottom - Top);
    Center := Top + (Height / 2);

    Result := Min(
      Floor(Center + (Height / 2)),
      Floor(Center + ((Self.Alignment.Center.MaxHeight - 1) / 2))
    );
  end else
    Result := Round(Self.Alignment.Bottom.Method() + Self.Alignment.Bottom.Offset);
   
  if Self.Cache.Enabled then  
    Self.Cache.Y2 := [Self.Mode, ClientWidth, ClientHeight, Result];
end;

function TRSInterface.Bounds: TBox; 
begin
  Result := [Self.X1, Self.Y1, Self.X2, Self.Y2];
end;

function TRSInterface.Width: Int32; 
begin
  Result := Bounds.Width;
end;

function TRSInterface.Height: Int32; 
begin
  Result := Bounds.Height;
end;

function TRSInterface.Center: TPoint; 
begin
  Result := Self.Bounds().Middle;
end;

type
  TRSScrollBar = record
    SliderRegion: TBox;
    Slider: TBox;
    Position: Int32;
  end;
  
procedure TRSScrollBar.Draw(Bitmap: TMufasaBitmap); constref;
begin
  Bitmap.DrawBox(Self.SliderRegion, $00FFFF);
  Bitmap.DrawBox(Self.Slider, $00FFFF);
  Bitmap.SetFontAntialiasing(False);
  Bitmap.SetFontSize(30);
  with Bitmap.TextSize(ToString(Self.Position)) do
    Bitmap.DrawText(ToString(Self.Position), [Self.SliderRegion.Middle.X - (X div 2), Self.Slider.Middle.Y - (Y div 3)], $00FF00);
end;

function TRSScrollBar.IsVisible: Boolean;
begin
  Result := Self <> [];
end;

function TRSInterface.GetScrollBar: TRSScrollBar;
const
  COLOR_ARROW := CTS2(5206147, 15, 0.03, 0.28);
  COLOR_BORDER := 65536;
var
  TPA: TPointArray;
  Arrows: TBoxArray;
  Area, B: TBox;
begin
  Area := Self.Bounds();
  
  if SRL.FindColors(TPA, COLOR_ARROW, Area) > 0 then
  begin
    for B in TPA.Cluster(1).ToTBA() do
      if (B.Width = 14) and (B.Height = 14) and (SRL.CountColor(COLOR_BORDER, B.Expand(1, Area)) = 62) then
        Arrows += B;
        
    Arrows.SortByX(False);   
    
    if (Length(Arrows) >= 2) and (Arrows[0].X1 = Arrows[1].X1) and (Arrows[1].X2 = Arrows[1].X2) then
    begin
      if (Arrows[0].Y1 > Arrows[1].Y1) then
        Swap(Arrows[0], Arrows[1]);
        
      B.X1 := Arrows[0].X1;
      B.Y1 := Arrows[0].Y2 + 2;
      B.X2 := Arrows[1].X2;
      B.Y2 := Arrows[1].Y1 - 2;
  
      if SRL.FindColors(TPA, COLOR_BORDER, B) > 0 then 
      begin
        Result.SliderRegion := B;
        Result.Slider := TPA.Bounds;
        Result.Position := Round((Result.Slider.Y1 - Result.SliderRegion.Y1) * 100 / (Result.SliderRegion.Height - Result.Slider.Height));
      end;
    end; 
  end;
end;

function TRSInterface.CanScroll: Boolean;
var
  ScrollBar: TRSScrollBar := Self.GetScrollBar();
begin
  Result := Scrollbar.IsVisible() and (ScrollBar.Slider <> ScrollBar.SliderRegion);
end;

function TRSInterface.GetScrollPosition: Int32;
var
  ScrollBar: TRSScrollBar;
begin
  Result := -1;
  
  ScrollBar := Self.GetScrollBar();
  if ScrollBar.IsVisible() then
    Result := ScrollBar.Position;
end;

procedure TRSInterface.SetScrollPosition(Value: Int32);
var
  ScrollBar: TRSScrollBar;
begin
  if (Value < 0) then
    Value := 0;
  if (Value > 100) then
    Value := 100;

  ScrollBar := Self.GetScrollBar();
  
  if ScrollBar.IsVisible() then
  begin
    if (ScrollBar.Position < Value) then 
    begin 
      while ScrollBar.IsVisible() and (ScrollBar.Position < Value) do
      begin
        Mouse.Scroll(ScrollBar.SliderRegion, Random(1, 3), True);
        
        ScrollBar := Self.GetScrollBar();
      end;
    end else
    if (ScrollBar.Position > Value) then 
    begin
      while ScrollBar.IsVisible() and (ScrollBar.Position > Value) do
      begin
        Mouse.Scroll(ScrollBar.SliderRegion, Random(1, 3), False);
        
        ScrollBar := Self.GetScrollBar();
      end;
    end;
  end;
end;

procedure TRSInterface.Draw(Bitmap: TMufasaBitmap);
var
  ScrollBar: TRSScrollBar;
  I: Integer;
begin
  Bitmap.DrawBox(Self.Bounds(), $00FFFF);

  for I:=0 to High(Self.Elements) do
    Bitmap.DrawBox(Self._ElementBounds(Self.Elements[I]), $00FF00);

  ScrollBar := Self.GetScrollBar();
  if ScrollBar.IsVisible() then
    ScrollBar.Draw(Bitmap); 
end; 

function TRSInterface.GetTitle: String;
var
  B: TBox;
begin
  B := Self.Bounds();
  B.X1 += 50;
  B.Y1 += 10;
  B.X2 -= 50;
  B.Y2 := B.Y1 + 15;
  B.LimitTo(Self.Bounds);

  Result := OCR.Recognize(B, TOCRThresholdRule.Create(15), RS_FONT_BOLD_12);
end;

function TRSInterface.ClickCloseButton(PressEscape: Boolean = False): Boolean;
var
  B: TBox;
begin
  B.X1 := Self.X2-28;
  B.X2 := Self.X2-6;
  B.Y1 := Self.Y1+6;
  B.Y2 := Self.Y1+28;

  Result := SRL.CountColor(65536, B) > 80;
  
  if Result then
  begin
    case PressEscape of
      False: Mouse.Click(B, MOUSE_LEFT);
      True:  Keyboard.PressKey(VK_ESCAPE);
    end;
  end;
end;

function TRSInterface.IsTitle(Text: String): Boolean; overload;
begin
  Result := Text in Self.GetTitle();
end;

function TRSInterface.IsTitle(Text: String; WaitTime: Int32): Boolean; overload;
begin
  Result := WaitUntil(Self.IsTitle(Text), 100, WaitTime);
end;

type
  TRSRootInterface = type TRSInterface;

function TRSRootInterface.X1: Int32; override;
begin
  Result := 0;
end;

function TRSRootInterface.Y1: Int32; override;
begin
  Result := 0;
end;

function TRSRootInterface.X2: Int32; override;
var
  ClientWidth, ClientHeight: Int32;
begin
  GetClientDimensions(ClientWidth, ClientHeight);

  Result := ClientWidth - 1;
end;

function TRSRootInterface.Y2: Int32; override;
var
  ClientWidth, ClientHeight: Int32;
begin
  GetClientDimensions(ClientWidth, ClientHeight);

  Result := ClientHeight - 1;
end;

var
  RootInterface: TRSRootInterface;

begin
  RootInterface.Name := 'Root Interface';
  RootInterface.Alignment.Left := [@RootInterface.X1];
  RootInterface.Alignment.Top := [@RootInterface.Y1];
  RootInterface.Alignment.Right := [@RootInterface.X2];
  RootInterface.Alignment.Bottom := [@RootInterface.Y2];
end;

